<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.1. Match</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The Neo4j Manual v2.0.0" /><link rel="up" href="query-read.html" title="Chapter 10. Reading Clauses" /><link rel="prev" href="query-read.html" title="Chapter 10. Reading Clauses" /><link rel="next" href="query-optional-match.html" title="10.2. Optional Match" /><link rel="preface" href="preface.html" title="Preface" /><link rel="part" href="introduction.html" title="Part I. Introduction" /><link rel="chapter" href="introduction-highlights.html" title="Chapter 1. Neo4j Highlights" /><link rel="chapter" href="graphdb-concepts.html" title="Chapter 2. Graph Database Concepts" /><link rel="chapter" href="graphdb-neo4j.html" title="Chapter 3. The Neo4j Graph Database" /><link rel="part" href="tutorials.html" title="Part II. Tutorials" /><link rel="chapter" href="tutorials-cypher.html" title="Chapter 4. Getting started with Cypher" /><link rel="chapter" href="data-modeling-examples.html" title="Chapter 5. Data Modeling Examples" /><link rel="chapter" href="languages.html" title="Chapter 6. Languages" /><link rel="part" href="cypher-query-lang.html" title="Part III. Cypher Query Language" /><link rel="chapter" href="cypher-intro.html" title="Chapter 7. Introduction" /><link rel="chapter" href="query-syntax.html" title="Chapter 8. Syntax" /><link rel="chapter" href="query-general.html" title="Chapter 9. General Clauses" /><link rel="chapter" href="query-read.html" title="Chapter 10. Reading Clauses" /><link rel="chapter" href="query-write.html" title="Chapter 11. Writing Clauses" /><link rel="chapter" href="query-function.html" title="Chapter 12. Functions" /><link rel="chapter" href="cypher-schema.html" title="Chapter 13. Schema" /><link rel="chapter" href="examples-from-sql-to-cypher.html" title="Chapter 14. From SQL to Cypher" /><link rel="part" href="reference-documentation.html" title="Part IV. Reference" /><link rel="chapter" href="capabilities.html" title="Chapter 15. Capabilities" /><link rel="chapter" href="transactions.html" title="Chapter 16. Transaction Management" /><link rel="chapter" href="import.html" title="Chapter 17. Data Import" /><link rel="chapter" href="graph-algo.html" title="Chapter 18. Graph Algorithms" /><link rel="chapter" href="rest-api.html" title="Chapter 19. REST API" /><link rel="chapter" href="deprecations.html" title="Chapter 20. Deprecations" /><link rel="part" href="operations.html" title="Part V. Operations" /><link rel="chapter" href="deployment.html" title="Chapter 21. Installation &amp; Deployment" /><link rel="chapter" href="embedded-configuration.html" title="Chapter 22. Configuration &amp; Performance" /><link rel="chapter" href="ha.html" title="Chapter 23. High Availability" /><link rel="chapter" href="operations-backup.html" title="Chapter 24. Backup" /><link rel="chapter" href="operations-security.html" title="Chapter 25. Security" /><link rel="chapter" href="operations-monitoring.html" title="Chapter 26. Monitoring" /><link rel="part" href="tools.html" title="Part VI. Tools" /><link rel="chapter" href="tools-webadmin.html" title="Chapter 27. Web Interface" /><link rel="chapter" href="shell.html" title="Chapter 28. Neo4j Shell" /><link rel="part" href="community.html" title="Part VII. Community" /><link rel="chapter" href="community-support.html" title="Chapter 29. Community Support" /><link rel="chapter" href="community-contributing.html" title="Chapter 30. Contributing to Neo4j" /><link rel="part" href="advanced-usage.html" title="Part VIII. Advanced Usage" /><link rel="chapter" href="server-extending.html" title="Chapter 31. Extending the Neo4j Server" /><link rel="chapter" href="tutorials-java-embedded.html" title="Chapter 32. Using Neo4j embedded in Java applications" /><link rel="chapter" href="tutorial-traversal.html" title="Chapter 33. The Traversal Framework" /><link rel="chapter" href="indexing.html" title="Chapter 34. Legacy Indexing" /><link rel="chapter" href="batchinsert.html" title="Chapter 35. Batch Insertion" /><link rel="appendix" href="manpages.html" title="Appendix A. Manpages" /><link rel="refentry" href="re01.html" title="neo4j" /><link rel="refentry" href="re02.html" title="neo4j-installer" /><link rel="refentry" href="re03.html" title="neo4j-shell" /><link rel="refentry" href="re04.html" title="neo4j-backup" /><link rel="refentry" href="re05.html" title="neo4j-arbiter" /><link rel="subsection" href="query-match.html#_introduction_2" title="10.1.1. Introduction" /><link rel="subsection" href="query-match.html#_basic_node_finding" title="10.1.2. Basic node finding" /><link rel="subsection" href="query-match.html#_relationship_basics" title="10.1.3. Relationship basics" /><link rel="subsection" href="query-match.html#_relationships_in_depth" title="10.1.4. Relationships in depth" /><link rel="subsection" href="query-match.html#_shortest_path" title="10.1.5. Shortest path" /><link rel="copyright" href="ln-idp218960.html" title="License: Creative Commons 3.0" />


<!-- favicon -->

<link rel="shortcut icon" href="http://neo4j.org/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="icon" href="http://neo4j.org/favicon.ico" type="image/x-icon" />

<!-- style -->

<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/neo.css" rel="stylesheet" type="text/css" />

<!-- Syntax Highlighter -->

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushBash.js"></script>
<script type="text/javascript" src="js/shBrushPlain.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushGroovy.js"></script>
<script type="text/javascript" src="js/shBrushCypher.js"></script>
<script type="text/javascript" src="js/shBrushScala.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript" src="js/shBrushPython.js"></script>
<script type="text/javascript" src="js/shBrushProperties.js"></script>

<!-- activate when needed
<script type="text/javascript" src="js/shBrushRuby.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
-->
 
<script type="text/javascript">
  SyntaxHighlighter.defaults['tab-size'] = 4;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all()
</script>

<!-- JQuery -->

<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>

<!-- Replace SVG for browsers that lack support. -->
<script type="text/javascript" src="js/svgreplacer.js"></script>

<!-- Image Scaler -->

<script type="text/javascript" src="js/imagescaler.js"></script>

<!-- Table Styler -->

<script type="text/javascript" src="js/tablestyler.js"></script>

<!-- Version -->

<script type="text/javascript" src="js/version.js"></script>

<!-- Offline Sidebar -->

<script type="text/javascript" src="js/sidebar.js"></script>


<div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">The Neo4j Manual</a></span> &gt; <span class="breadcrumb-link"><a href="cypher-query-lang.html">Cypher Query Language</a></span> &gt; <span class="breadcrumb-link"><a href="query-read.html">Reading Clauses</a></span> &gt; <span class="breadcrumb-node">Match</span></div></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="query-read.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="query-optional-match.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="query-match"></a>10.1. Match</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="query-match.html#_introduction_2">10.1.1. Introduction</a></span></dt><dt><span class="section"><a href="query-match.html#_basic_node_finding">10.1.2. Basic node finding</a></span></dt><dt><span class="section"><a href="query-match.html#_relationship_basics">10.1.3. Relationship basics</a></span></dt><dt><span class="section"><a href="query-match.html#_relationships_in_depth">10.1.4. Relationships in depth</a></span></dt><dt><span class="section"><a href="query-match.html#_shortest_path">10.1.5. Shortest path</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_introduction_2"></a>10.1.1. Introduction</h3></div></div></div><p><code class="literal">MATCH</code> is the primary way of getting data from the database into the current set of bindings.</p><p>The <code class="literal">MATCH</code> clause allows you to specify the patterns Cypher will search for in the database.</p><p>Nodes and relationships that are already known at this stage are called <span class="emphasis"><em>bound pattern elements</em></span>.
Cypher will now try to find the unknown parts of the pattern.</p><p>If <code class="literal">MATCH</code> is the first clause in your query, nothing is bound at this stage.
Cypher needs starting points to do it’s pattern matching.</p><p>If no bound nodes exist, Cypher can scan all nodes in the database, all nodes with a certain label, or it can use indexes to quickly find the relevant starting points.
For more information on indexes, see <a class="xref" href="query-schema-index.html" title="13.1. Indexes">Section 13.1, “Indexes”</a>.
If you want to use index hints to force Cypher to use a specific index, read more in <a class="xref" href="query-using.html" title="9.7. Using">Section 9.7, “Using”</a>.</p><p><code class="literal">WHERE</code> defines the <code class="literal">MATCH</code> patterns in more detail.
The predicates are part of the pattern description, not a filter applied after the matching is done.
This means that <code class="literal">WHERE</code> should always be put together with the <code class="literal">MATCH</code> clause it belongs to.</p><p>After finding starting points — either by using scans, indexes or already bound points — the execution engine will use pattern matching to find matching subgraphs.
As Cypher is declarative, it can change the order of these operations.
Predicates in <code class="literal">WHERE</code> clauses can be evaluated before pattern matching, during pattern matching, or after finding matches.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/icons/admon/tip.png" /></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>To understand the patterns used in the <code class="literal">MATCH</code> clause, read <a class="xref" href="introduction-pattern.html" title="8.5. Patterns">Section 8.5, “Patterns”</a>.</p></td></tr></table></div><p>The following graph is used for the examples below:</p><div class="figure"><a id="idp8724336"></a><p class="title"><strong>Figure 10.1. Graph</strong></p><div class="figure-contents"><a class="ulink" href="images/cypher-match-graph.svg" target="_top">
<span class="inlinemediaobject"><img src="images/cypher-match-graph.svg" alt="cypher-match-graph.svg" /></span>
</a></div></div><br class="figure-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_basic_node_finding"></a>10.1.2. Basic node finding</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-get-all-nodes"></a>Get all nodes</h4></div></div></div><p>By just specifying a pattern with a single node and no labels, all nodes in the graph will be returned.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (n)
RETURN n</pre><p>
</p><p>Returns all the nodes in the database.</p><div class="queryresult table"><a id="idp8733120"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">n</th></tr></thead><tfoot><tr><th align="left" valign="top">7 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[0]{name:"Oliver Stone"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Charlie Sheen"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Martin Sheen"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"TheAmericanPresident",title:"The American President"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"WallStreet",title:"Wall Street"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[5]{name:"Rob Reiner"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[6]{name:"Michael Douglas"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-get-all-nodes-with-a-label"></a>Get all nodes with a label</h4></div></div></div><p>Getting all nodes with a label on them is done with a single node pattern where the node has a label on it.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (movie:Movie)
RETURN movie</pre><p>
</p><p>Returns all the movies in the database.</p><div class="queryresult table"><a id="idp8756320"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">movie</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"TheAmericanPresident",title:"The American President"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"WallStreet",title:"Wall Street"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-related-nodes"></a>Related nodes</h4></div></div></div><p>The symbol <code class="literal">--</code> means <span class="emphasis"><em>related to,</em></span> without regard to type or direction of the relationship.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (director { name:'Oliver Stone' })--(movie)
RETURN movie.title</pre><p>
</p><p>Returns all the movies directed by Oliver Stone.</p><div class="queryresult table"><a id="idp8773328"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">movie.title</th></tr></thead><tfoot><tr><th align="left" valign="top">1 row</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"Wall Street"</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-match-with-labels"></a>Match with labels</h4></div></div></div><p>To constrain your pattern with labels on nodes, you add it to your pattern nodes, using the label syntax.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (charlie:Person { name:'Charlie Sheen' })--(movie:Movie)
RETURN movie</pre><p>
</p><p>Return any nodes connected with the <code class="literal">Person</code> Charlie that are labeled <code class="literal">Movie</code>.</p><div class="queryresult table"><a id="idp8789104"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">movie</th></tr></thead><tfoot><tr><th align="left" valign="top">1 row</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"WallStreet",title:"Wall Street"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_relationship_basics"></a>10.1.3. Relationship basics</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-outgoing-relationships"></a>Outgoing relationships</h4></div></div></div><p>When the direction of a relationship is interesting, it is shown by using <code class="literal">--&gt;</code> or <code class="literal">&lt;--</code>, like this:</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (martin { name:'Martin Sheen' })--&gt;(movie)
RETURN movie.title</pre><p>
</p><p>Returns nodes connected to Martin by outgoing relationships.</p><div class="queryresult table"><a id="idp8806304"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">movie.title</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"Wall Street"</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">"The American President"</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-directed-relationships-and-identifier"></a>Directed relationships and identifier</h4></div></div></div><p>If an identifier is needed, either for filtering on properties of the relationship, or to return the relationship, this is how you introduce the identifier.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (martin { name:'Martin Sheen' })-[r]-&gt;(movie)
RETURN r</pre><p>
</p><p>Returns all outgoing relationships from Martin.</p><div class="queryresult table"><a id="idp8822144"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">r</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:ACTED_IN[1]{}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">:ACTED_IN[3]{}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-match-by-relationship-type"></a>Match by relationship type</h4></div></div></div><p>When you know the relationship type you want to match on, you can specify it by using a colon together with the relationship type.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (wallstreet { title:'Wall Street' })&lt;-[:ACTED_IN]-(actor)
RETURN actor</pre><p>
</p><p>Returns nodes that <code class="literal">ACTED_IN</code> Wall Street.</p><div class="queryresult table"><a id="idp8838656"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">actor</th></tr></thead><tfoot><tr><th align="left" valign="top">3 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Charlie Sheen"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Martin Sheen"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[6]{name:"Michael Douglas"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-match-by-multiple-relationship-types"></a>Match by multiple relationship types</h4></div></div></div><p>To match on one of multiple types, you can specify this by chaining them together with the pipe symbol <code class="literal">|</code>.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (wallstreet { title:'Wall Street' })&lt;-[:ACTED_IN|:DIRECTED]-(person)
RETURN person</pre><p>
</p><p>Returns nodes with a <code class="literal">ACTED_IN</code> or <code class="literal">DIRECTED</code> relationship to Wall Street.</p><div class="queryresult table"><a id="idp8858336"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">person</th></tr></thead><tfoot><tr><th align="left" valign="top">4 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[0]{name:"Oliver Stone"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Charlie Sheen"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Martin Sheen"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[6]{name:"Michael Douglas"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-match-by-relationship-type-and-use-an-identifier"></a>Match by relationship type and use an identifier</h4></div></div></div><p>If you both want to introduce an identifier to hold the relationship, and specify the relationship type you want, just add them both, like this.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (wallstreet { title:'Wall Street' })&lt;-[r:ACTED_IN]-(actor)
RETURN r</pre><p>
</p><p>Returns nodes that <code class="literal">ACTED_IN</code> Wall Street.</p><div class="queryresult table"><a id="idp8878096"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">r</th></tr></thead><tfoot><tr><th align="left" valign="top">3 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:ACTED_IN[0]{}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">:ACTED_IN[1]{}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">:ACTED_IN[2]{}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_relationships_in_depth"></a>10.1.4. Relationships in depth</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-relationship-types-with-uncommon-characters"></a>Relationship types with uncommon characters</h4></div></div></div><p>Sometime your database will have types with non-letter characters, or with spaces in them. Use <code class="literal">`</code> (backtick) to quote these.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (n { name:'Rob Reiner' })-[r:`TYPE THAT HAS SPACE IN IT`]-&gt;()
RETURN r</pre><p>
</p><p>Returns a relationship of a type with spaces in it.</p><div class="queryresult table"><a id="idp8897360"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">r</th></tr></thead><tfoot><tr><th align="left" valign="top">1 row</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">:TYPE THAT HAS SPACE IN IT[8]{}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-multiple-relationships"></a>Multiple relationships</h4></div></div></div><p>Relationships can be expressed by using multiple statements in the form of <code class="literal">()--()</code>, or they can be strung together, like this:</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (charlie { name:'Charlie Sheen' })-[:ACTED_IN]-&gt;(movie)&lt;-[:DIRECTED]-&gt;(director)
RETURN charlie,movie,director</pre><p>
</p><p>Returns the three nodes in the path.</p><div class="queryresult table"><a id="idp8912640"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th align="left" valign="top">charlie</th><th align="left" valign="top">movie</th><th align="left" valign="top">director</th></tr></thead><tfoot><tr><th colspan="3" align="left" valign="top">1 row</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Charlie Sheen"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"WallStreet",title:"Wall Street"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[0]{name:"Oliver Stone"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-variable-length-relationships"></a>Variable length relationships</h4></div></div></div><p>Nodes that are a variable number of relationship→node hops away can be found using the following syntax: <code class="literal">-[:TYPE*minHops..maxHops]-&gt;</code>. minHops and maxHops are optional and default to 1 and infinity respectively. When no bounds are given the dots may be omitted.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (martin { name:"Martin Sheen" })-[:ACTED_IN*1..2]-(x)
RETURN x</pre><p>
</p><p>Returns nodes that are 1 or 2 relationships away from Martin.</p><div class="queryresult table"><a id="idp8933504"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">x</th></tr></thead><tfoot><tr><th align="left" valign="top">5 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"WallStreet",title:"Wall Street"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Charlie Sheen"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[6]{name:"Michael Douglas"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[3]{name:"TheAmericanPresident",title:"The American President"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[6]{name:"Michael Douglas"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-relationship-identifier-in-variable-length-relationships"></a>Relationship identifier in variable length relationships</h4></div></div></div><p>When the connection between two nodes is of variable length, a relationship identifier becomes an collection of relationships.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (actor { name:'Charlie Sheen' })-[r:ACTED_IN*2]-(co_actor)
RETURN r</pre><p>
</p><p>The query returns a collection of relationships.</p><div class="queryresult table"><a id="idp8953968"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">r</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[:ACTED_IN[0]{},:ACTED_IN[1]{}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[:ACTED_IN[0]{},:ACTED_IN[2]{}]</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-match-with-properties-on-a-variable-length-path"></a>Match with properties on a variable length path</h4></div></div></div><p>A variable length relationship with properties defined on in it means that all relationships in the path
must have the property set to the given value. In this query, there are two paths between Charile Sheen and his
dad Martin Sheen. One of the includes a “blocked” relationship and the other doesn’t.
In this case we first alter the original graph by using the following query to add “blocked” and “unblocked” relationships:</p><pre class="programlisting brush: cypher">MATCH (charlie:Person { name:'Charlie Sheen' }),(martin:Person { name:'Martin Sheen' })
CREATE (charlie)-[:X { blocked:false }]-&gt;(:Unblocked)&lt;-[:X { blocked:false }]-(martin)
CREATE (charlie)-[:X { blocked:true }]-&gt;(:Blocked)&lt;-[:X { blocked:false }]-(martin);</pre><p>This means that we are starting out with the following graph:</p><div class="informalfigure"><a class="ulink" href="images/match-match-with-properties-on-a-variable-length-path.preparation-graph.svg" target="_top">
<span class="inlinemediaobject"><img src="images/match-match-with-properties-on-a-variable-length-path.preparation-graph.svg" alt="match-match-with-properties-on-a-variable-length-path.preparation-graph.svg" /></span>
</a></div><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH p =(charlie:Person)-[* { blocked:false }]-(martin:Person)
WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'
RETURN p</pre><p>
</p><p>Returns the paths between Charlie and Martin Sheen where all relationships have the <code class="literal">blocked</code> property set to <code class="literal">FALSE</code>.</p><div class="queryresult table"><a id="idp8977920"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">p</th></tr></thead><tfoot><tr><th align="left" valign="top">1 row</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[1]{name:"Charlie Sheen"},:X[12]{blocked:false},Node[9]{},:X[13]{blocked:false},Node[2]{name:"Martin Sheen"}]</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-zero-length-paths"></a>Zero length paths</h4></div></div></div><p>Using variable length paths that have the lower bound zero means that two identifiers can point to the same node. If the distance between two nodes is zero, they are by definition the same node. Note that when matching zero length paths the result may contain a match even when matching on a relationship type not in use.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (wallstreet:Movie { title:'Wall Street' })-[*0..1]-(x)
RETURN x</pre><p>
</p><p>Returns all nodes that are zero or one relationships away from Wall Street.</p><div class="queryresult table"><a id="idp8992672"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">x</th></tr></thead><tfoot><tr><th align="left" valign="top">5 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"WallStreet",title:"Wall Street"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Charlie Sheen"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[2]{name:"Martin Sheen"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[6]{name:"Michael Douglas"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[0]{name:"Oliver Stone"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-named-path"></a>Named path</h4></div></div></div><p>If you want to return or filter on a path in your pattern graph, you can a introduce a named path.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH p =(michael { name:'Michael Douglas' })--&gt;()
RETURN p</pre><p>
</p><p>Returns the two paths starting from Michael.</p><div class="queryresult table"><a id="idp9012928"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">p</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[6]{name:"Michael Douglas"},:ACTED_IN[2]{},Node[4]{name:"WallStreet",title:"Wall Street"}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[Node[6]{name:"Michael Douglas"},:ACTED_IN[4]{},Node[3]{name:"TheAmericanPresident",title:"The American President"}]</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-matching-on-a-bound-relationship"></a>Matching on a bound relationship</h4></div></div></div><p>When your pattern contains a bound relationship, and that relationship pattern doesn’t specify direction,
Cypher will try to match the relationship in both directions.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (a)-[r]-(b)
WHERE id(r)= 0
RETURN a,b</pre><p>
</p><p>This returns the two connected nodes, once as the start node, and once as the end node.</p><div class="queryresult table"><a id="idp9029056"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th align="left" valign="top">a</th><th align="left" valign="top">b</th></tr></thead><tfoot><tr><th colspan="2" align="left" valign="top">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Charlie Sheen"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[4]{name:"WallStreet",title:"Wall Street"}</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Node[4]{name:"WallStreet",title:"Wall Street"}</code></p></td><td align="left" valign="top"><p><code class="literal">Node[1]{name:"Charlie Sheen"}</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_shortest_path"></a>10.1.5. Shortest path</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-single-shortest-path"></a>Single shortest path</h4></div></div></div><p>Finding a single shortest path between two nodes is as easy as using the <code class="literal">shortestPath</code> function. It’s done like this:</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (martin:Person { name:"Martin Sheen" }),(oliver:Person { name:"Oliver Stone" }),
  p = shortestPath((martin)-[*..15]-(oliver))
RETURN p</pre><p>
</p><p>This means: find a single shortest path between two nodes, as long as the path is max 15 relationships long. Inside of the parentheses
 you define a single link of a path — the starting node, the connecting relationship and the end node. Characteristics describing the relationship
 like relationship type, max hops and direction are all used when finding the shortest path. You can also mark the path as optional.</p><div class="queryresult table"><a id="idp9051904"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">p</th></tr></thead><tfoot><tr><th align="left" valign="top">1 row</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[2]{name:"Martin Sheen"},:ACTED_IN[1]{},Node[4]{name:"WallStreet",title:"Wall Street"},:DIRECTED[5]{},Node[0]{name:"Oliver Stone"}]</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="match-all-shortest-paths"></a>All shortest paths</h4></div></div></div><p>Finds all the shortest paths between two nodes.</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (martin:Person { name:"Martin Sheen" }),(michael:Person { name:"Michael Douglas" }),
  p = allShortestPaths((martin)-[*]-(michael))
RETURN p</pre><p>
</p><p>Finds the two shortest paths between Martin and Michael.</p><div class="queryresult table"><a id="idp9066592"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">p</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">[Node[2]{name:"Martin Sheen"},:ACTED_IN[3]{},Node[3]{name:"TheAmericanPresident",title:"The American President"},:ACTED_IN[4]{},Node[6]{name:"Michael Douglas"}]</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">[Node[2]{name:"Martin Sheen"},:ACTED_IN[1]{},Node[4]{name:"WallStreet",title:"Wall Street"},:ACTED_IN[2]{},Node[6]{name:"Michael Douglas"}]</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /></div></div></div><HR xmlns=""></HR><a xmlns="" href="ln-idp218960.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2013 Neo Technology</p></a><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="query-read.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="query-read.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="query-optional-match.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
