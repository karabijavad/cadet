<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>22.12. Linux Performance Guide</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The Neo4j Manual v2.0.0" /><link rel="up" href="embedded-configuration.html" title="Chapter 22. Configuration &amp; Performance" /><link rel="prev" href="configuration-io-examples.html" title="22.11. Memory mapped IO settings" /><link rel="next" href="ha.html" title="Chapter 23. High Availability" /><link rel="preface" href="preface.html" title="Preface" /><link rel="part" href="introduction.html" title="Part I. Introduction" /><link rel="chapter" href="introduction-highlights.html" title="Chapter 1. Neo4j Highlights" /><link rel="chapter" href="graphdb-concepts.html" title="Chapter 2. Graph Database Concepts" /><link rel="chapter" href="graphdb-neo4j.html" title="Chapter 3. The Neo4j Graph Database" /><link rel="part" href="tutorials.html" title="Part II. Tutorials" /><link rel="chapter" href="tutorials-cypher.html" title="Chapter 4. Getting started with Cypher" /><link rel="chapter" href="data-modeling-examples.html" title="Chapter 5. Data Modeling Examples" /><link rel="chapter" href="languages.html" title="Chapter 6. Languages" /><link rel="part" href="cypher-query-lang.html" title="Part III. Cypher Query Language" /><link rel="chapter" href="cypher-intro.html" title="Chapter 7. Introduction" /><link rel="chapter" href="query-syntax.html" title="Chapter 8. Syntax" /><link rel="chapter" href="query-general.html" title="Chapter 9. General Clauses" /><link rel="chapter" href="query-read.html" title="Chapter 10. Reading Clauses" /><link rel="chapter" href="query-write.html" title="Chapter 11. Writing Clauses" /><link rel="chapter" href="query-function.html" title="Chapter 12. Functions" /><link rel="chapter" href="cypher-schema.html" title="Chapter 13. Schema" /><link rel="chapter" href="examples-from-sql-to-cypher.html" title="Chapter 14. From SQL to Cypher" /><link rel="part" href="reference-documentation.html" title="Part IV. Reference" /><link rel="chapter" href="capabilities.html" title="Chapter 15. Capabilities" /><link rel="chapter" href="transactions.html" title="Chapter 16. Transaction Management" /><link rel="chapter" href="import.html" title="Chapter 17. Data Import" /><link rel="chapter" href="graph-algo.html" title="Chapter 18. Graph Algorithms" /><link rel="chapter" href="rest-api.html" title="Chapter 19. REST API" /><link rel="chapter" href="deprecations.html" title="Chapter 20. Deprecations" /><link rel="part" href="operations.html" title="Part V. Operations" /><link rel="chapter" href="deployment.html" title="Chapter 21. Installation &amp; Deployment" /><link rel="chapter" href="embedded-configuration.html" title="Chapter 22. Configuration &amp; Performance" /><link rel="chapter" href="ha.html" title="Chapter 23. High Availability" /><link rel="chapter" href="operations-backup.html" title="Chapter 24. Backup" /><link rel="chapter" href="operations-security.html" title="Chapter 25. Security" /><link rel="chapter" href="operations-monitoring.html" title="Chapter 26. Monitoring" /><link rel="part" href="tools.html" title="Part VI. Tools" /><link rel="chapter" href="tools-webadmin.html" title="Chapter 27. Web Interface" /><link rel="chapter" href="shell.html" title="Chapter 28. Neo4j Shell" /><link rel="part" href="community.html" title="Part VII. Community" /><link rel="chapter" href="community-support.html" title="Chapter 29. Community Support" /><link rel="chapter" href="community-contributing.html" title="Chapter 30. Contributing to Neo4j" /><link rel="part" href="advanced-usage.html" title="Part VIII. Advanced Usage" /><link rel="chapter" href="server-extending.html" title="Chapter 31. Extending the Neo4j Server" /><link rel="chapter" href="tutorials-java-embedded.html" title="Chapter 32. Using Neo4j embedded in Java applications" /><link rel="chapter" href="tutorial-traversal.html" title="Chapter 33. The Traversal Framework" /><link rel="chapter" href="indexing.html" title="Chapter 34. Legacy Indexing" /><link rel="chapter" href="batchinsert.html" title="Chapter 35. Batch Insertion" /><link rel="appendix" href="manpages.html" title="Appendix A. Manpages" /><link rel="refentry" href="re01.html" title="neo4j" /><link rel="refentry" href="re02.html" title="neo4j-installer" /><link rel="refentry" href="re03.html" title="neo4j-shell" /><link rel="refentry" href="re04.html" title="neo4j-backup" /><link rel="refentry" href="re05.html" title="neo4j-arbiter" /><link rel="subsection" href="linux-performance-guide.html#_introduction_6" title="22.12.1. Introduction" /><link rel="subsection" href="linux-performance-guide.html#_file_system_benchmark" title="22.12.2. File system benchmark" /><link rel="subsection" href="linux-performance-guide.html#_file_system_tuning_for_high_io" title="22.12.3. File system tuning for high IO" /><link rel="subsection" href="linux-performance-guide.html#_setting_the_number_of_open_files" title="22.12.4. Setting the number of open files" /><link rel="copyright" href="ln-idp218960.html" title="License: Creative Commons 3.0" />


<!-- favicon -->

<link rel="shortcut icon" href="http://neo4j.org/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="icon" href="http://neo4j.org/favicon.ico" type="image/x-icon" />

<!-- style -->

<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/neo.css" rel="stylesheet" type="text/css" />

<!-- Syntax Highlighter -->

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushBash.js"></script>
<script type="text/javascript" src="js/shBrushPlain.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushGroovy.js"></script>
<script type="text/javascript" src="js/shBrushCypher.js"></script>
<script type="text/javascript" src="js/shBrushScala.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript" src="js/shBrushPython.js"></script>
<script type="text/javascript" src="js/shBrushProperties.js"></script>

<!-- activate when needed
<script type="text/javascript" src="js/shBrushRuby.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
-->
 
<script type="text/javascript">
  SyntaxHighlighter.defaults['tab-size'] = 4;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all()
</script>

<!-- JQuery -->

<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>

<!-- Replace SVG for browsers that lack support. -->
<script type="text/javascript" src="js/svgreplacer.js"></script>

<!-- Image Scaler -->

<script type="text/javascript" src="js/imagescaler.js"></script>

<!-- Table Styler -->

<script type="text/javascript" src="js/tablestyler.js"></script>

<!-- Version -->

<script type="text/javascript" src="js/version.js"></script>

<!-- Offline Sidebar -->

<script type="text/javascript" src="js/sidebar.js"></script>


<div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">The Neo4j Manual</a></span> &gt; <span class="breadcrumb-link"><a href="operations.html">Operations</a></span> &gt; <span class="breadcrumb-link"><a href="embedded-configuration.html">Configuration &amp; Performance</a></span> &gt; <span class="breadcrumb-node">Linux Performance Guide</span></div></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="configuration-io-examples.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ha.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="linux-performance-guide"></a>22.12. Linux Performance Guide</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="linux-performance-guide.html#_introduction_6">22.12.1. Introduction</a></span></dt><dt><span class="section"><a href="linux-performance-guide.html#_file_system_benchmark">22.12.2. File system benchmark</a></span></dt><dt><span class="section"><a href="linux-performance-guide.html#_file_system_tuning_for_high_io">22.12.3. File system tuning for high IO</a></span></dt><dt><span class="section"><a href="linux-performance-guide.html#_setting_the_number_of_open_files">22.12.4. Setting the number of open files</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_introduction_6"></a>22.12.1. Introduction</h3></div></div></div><p>The key to achieve good performance on reads and writes is to have lots of RAM since disks are so slow. This guide will focus on achieving good write performance on a Linux kernel based operating system.</p><p>If you have not already read the information available in <a class="xref" href="embedded-configuration.html" title="Chapter 22. Configuration &amp; Performance">Chapter 22, <em>Configuration &amp; Performance</em></a>, do that now to get some basic knowledge on memory mapping and store files with Neo4j.</p><p>This section will guide you through how to set up a file system benchmark and use it to configure your system in a better way.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_file_system_benchmark"></a>22.12.2. File system benchmark</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_setup"></a>Setup</h4></div></div></div><p>Create a large file with random data. The file should fit in RAM so if your machine has 4GB of RAM a 1-2GB file with random data will be enough. After the file has been created we will read the file sequentially a few times to make sure it is cached.</p><pre class="programlisting brush: shell">$ dd if=/dev/urandom of=store bs=1M count=1000
1000+0 records in
1000+0 records out
1048576000 bytes (1.0 GB) copied, 263.53 s, 4.0 MB/s
$
$ dd if=store of=/dev/null bs=100M
10+0 records in
10+0 records out
1048576000 bytes (1.0 GB) copied, 38.6809 s, 27.1 MB/s
$
$ dd if=store of=/dev/null bs=100M
10+0 records in
10+0 records out
1048576000 bytes (1.0 GB) copied, 1.52365 s, 688 MB/s
$ dd if=store of=/dev/null bs=100M
10+0 records in
10+0 records out
1048576000 bytes (1.0 GB) copied, 0.776044 s, 1.4 GB/s</pre><p>If you have a standard hard drive in the machine you may know that it is not capable of transfer speeds as high as 1.4GB/s. What is measured is how fast we can read a file that is cached for us by the operating system.</p><p>Next we will use a small utility that simulates the Neo4j kernel behavior to benchmark write speed of the system.</p><pre class="programlisting brush: shell">$ git clone git@github.com:neo4j-contrib/tooling.git
...
$ cd tooling/write-test/
$ mvn compile
[INFO] Scanning for projects...
...
$ ./run
Usage: &lt;large file&gt; &lt;log file&gt; &lt;[record size] [min tx size] [max tx size] [tx count] &lt;[--nosync | --nowritelog | --nowritestore | --noread | --nomemorymap]&gt;&gt;</pre><p>The utility will be given a store file (large file we just created) and a name of a log file. Then a record size in bytes, min tx size, max tx size and transaction count must be set. When started the utility will map the large store file entirely in memory and read (transaction size) records from it randomly and then write them sequentially to the log file. The log file will then force changes to disk and finally the records will be written back to the store file.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_running_the_benchmark"></a>Running the benchmark</h4></div></div></div><p>Lets try to benchmark 100 transactions of size 100-500 with a record size of 33 bytes (same record size used by the relationship store).</p><pre class="programlisting brush: shell">$ ./run store logfile 33 100 500 100
tx_count[100] records[30759] fdatasyncs[100] read[0.96802425 MB] wrote[1.9360485 MB]
Time was: 4.973
20.108585 tx/s, 6185.2 records/s, 20.108585 fdatasyncs/s, 199.32773 kB/s on reads, 398.65546 kB/s on writes</pre><p>We see that we get about 6185 record updates/s and 20 transactions/s with the current transaction size. We can change the transaction size to be bigger, for example writing 10 transactions of size 1000-5000 records:</p><pre class="programlisting brush: shell">$ ./run store logfile 33 1000 5000 10
tx_count[10] records[24511] fdatasyncs[10] read[0.77139187 MB] wrote[1.5427837 MB]
Time was: 0.792
12.626263 tx/s, 30948.232 records/s, 12.626263 fdatasyncs/s, 997.35516 kB/s on reads, 1994.7103 kB/s on writes</pre><p>With larger transaction we will do fewer of them per second but record throughput will increase. Lets see if it scales, 10 transactions in under 1s then 100 of them should execute in about 10s:</p><pre class="programlisting brush: shell">$ ./run store logfile 33 1000 5000 100
tx_count[100] records[308814] fdatasyncs[100] read[9.718763 MB] wrote[19.437527 MB]
Time was: 65.115
1.5357445 tx/s, 4742.594 records/s, 1.5357445 fdatasyncs/s, 152.83751 kB/s on reads, 305.67502 kB/s on writes</pre><p>This is not very linear scaling. We modified a bit more than 10x records in total but the time jumped up almost 100x. Running the benchmark watching vmstat output will reveal that something is not as it should be:</p><pre class="programlisting brush: shell">$ vmstat 3
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
 0  1  47660 298884 136036 2650324    0    0     0 10239 1167 2268  5  7 46 42
 0  1  47660 302728 136044 2646060    0    0     0  7389 1267 2627  6  7 47 40
 0  1  47660 302408 136044 2646024    0    0     0 11707 1861 2016  8  5 48 39
 0  2  47660 302472 136060 2646432    0    0     0 10011 1704 1878  4  7 49 40
 0  1  47660 303420 136068 2645788    0    0     0 13807 1406 1601  4  5 44 47</pre><p>There are a lot of blocks going out to IO, way more than expected for the write speed we are seeing in the benchmark. Another observation that can be made is that the Linux kernel has spawned a process called "flush-x:x" (run top) that seems to be consuming a lot of resources.</p><p>The problem here is that the Linux kernel is trying to be smart and write out dirty pages from the virtual memory. As the benchmark will memory map a 1GB file and do random writes it is likely that this will result in 1/4 of the memory pages available on the system to be marked as dirty. The Neo4j kernel is not sending any system calls to the Linux kernel to write out these pages to disk however the Linux kernel decided to start doing so and it is a very bad decision. The result is that instead of doing sequential like writes down to disk (the logical log file) we are now doing random writes writing regions of the memory mapped file to disk.</p><p>It is possible to observe this behavior in more detail by looking at /proc/vmstat "nr_dirty" and "nr_writeback" values. By default the Linux kernel will start writing out pages at a very low ratio of dirty pages (10%).</p><pre class="programlisting brush: shell">$ sync
$ watch grep -A 1 dirty /proc/vmstat
...
nr_dirty 22
nr_writeback 0</pre><p>The "sync" command will write out all data (that needs writing) from memory to disk. The second command will watch the "nr_dirty" and "nr_writeback" count from vmstat. Now start the benchmark again and observe the numbers:</p><pre class="programlisting brush: shell">nr_dirty 124947
nr_writeback 232</pre><p>The "nr_dirty" pages will quickly start to rise and after a while the "nr_writeback" will also increase meaning the Linux kernel is scheduling a lot of pages to write out to disk.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_fixing_the_problem"></a>Fixing the problem</h4></div></div></div><p>As we have 4GB RAM on the machine and memory map a 1GB file that does not need its content written to disk (until we tell it to do so because of logical log rotation or Neo4j kernel shutdown) it should be possible to do endless random writes to that memory with high throughput. All we have to do is to tell the Linux kernel to stop trying to be smart. Edit the /etc/sysctl.conf (need root access) and add the following lines:</p><pre class="programlisting brush: shell">vm.dirty_background_ratio = 50
vm.dirty_ratio = 80</pre><p>Then (as root) execute:</p><pre class="programlisting brush: shell"># sysctl -p</pre><p>The "vm.dirty_background_ratio" tells at what ratio should the linux kernel start the background task of writing out dirty pages. We increased this from the default 10% to 50% and that should cover the 1GB memory mapped file.
The "vm.dirty_ratio" tells at what ratio all IO writes become synchronous,
meaning that we can not do IO calls without waiting for the underlying
device to complete them (which is something you never want to happen).</p><p>Rerun the benchmark:</p><pre class="programlisting brush: shell">$ ./run store logfile 33 1000 5000 100
tx_count[100] records[265624] fdatasyncs[100] read[8.35952 MB] wrote[16.71904 MB]
Time was: 6.781
14.7470875 tx/s, 39171.805 records/s, 14.7470875 fdatasyncs/s, 1262.3726 kB/s on reads, 2524.745 kB/s on writes</pre><p>Results are now more in line with what can be expected, 10x more records modified results in 10x longer execution time. The vmstat utility will not report any absurd amount of IO blocks going out (it reports the ones caused by the fdatasync to the logical log) and Linux kernel will not spawn a "flush-x:x" background process writing out dirty pages caused by writes to the memory mapped store file.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_file_system_tuning_for_high_io"></a>22.12.3. File system tuning for high IO</h3></div></div></div><p>In order to support the high IO load of small transactions from a database, the underlying file system should be tuned.
Symptoms for this are low CPU load with high iowait.
In this case, there are a couple of tweaks possible on Linux systems:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Disable access-time updates: <code class="literal">noatime,nodiratime</code> flags for disk mount command or in the <span class="emphasis"><em>/etc/fstab</em></span> for the database disk volume mount.
</li><li class="listitem">
Tune the IO scheduler for high disk IO on the database disk.
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_setting_the_number_of_open_files"></a>22.12.4. Setting the number of open files</h3></div></div></div><p>Linux platforms impose an upper limit on the number of concurrent files a user may have open. This number is reported for the current user and session with the command</p><pre class="programlisting brush: shell">user@localhost:~$ ulimit -n
1024</pre><p>The usual default of 1024 is often not enough, especially when many indexes are used or a server installation sees too many connections (network sockets count against that limit as well).
Users are therefore encouraged to increase that limit to a healthy value of 40000 or more, depending on usage patterns.
Setting this value via the <code class="literal">ulimit</code> command is possible only for the root user and that for that session only.
To set the value system wide you have to follow the instructions for your platform.</p><p>What follows is the procedure to set the open file descriptor limit to 40k for user neo4j under Ubuntu 10.04 and later.
If you opted to run the neo4j service as a different user, change the first field in step 2 accordingly.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
Become root since all operations that follow require editing protected system files.
</p><pre class="programlisting brush: shell">user@localhost:~$ sudo su -
Password:
root@localhost:~$</pre></li><li class="listitem"><p class="simpara">
Edit <code class="literal">/etc/security/limits.conf</code> and add these two lines:
</p><pre class="programlisting brush: shell">neo4j   soft    nofile  40000
neo4j   hard    nofile  40000</pre></li><li class="listitem"><p class="simpara">
Edit <code class="literal">/etc/pam.d/su</code> and uncomment or add the following line:
</p><pre class="programlisting brush: shell">session    required   pam_limits.so</pre></li><li class="listitem"><p class="simpara">
A restart is required for the settings to take effect.
</p><p class="simpara">After the above procedure, the neo4j user will have a limit of 40000 simultaneous open files. If you continue experiencing exceptions on <code class="literal">Too many open files</code> or <code class="literal">Could not stat() directory</code> then you may have to raise that limit further.</p></li></ol></div></div></div><HR xmlns=""></HR><a xmlns="" href="ln-idp218960.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2013 Neo Technology</p></a><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="configuration-io-examples.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="embedded-configuration.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ha.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
