<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.5. Patterns</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /><link rel="home" href="index.html" title="The Neo4j Manual v2.0.0" /><link rel="up" href="query-syntax.html" title="Chapter 8. Syntax" /><link rel="prev" href="cypher-comments.html" title="8.4. Comments" /><link rel="next" href="syntax-collections.html" title="8.6. Collections" /><link rel="preface" href="preface.html" title="Preface" /><link rel="part" href="introduction.html" title="Part I. Introduction" /><link rel="chapter" href="introduction-highlights.html" title="Chapter 1. Neo4j Highlights" /><link rel="chapter" href="graphdb-concepts.html" title="Chapter 2. Graph Database Concepts" /><link rel="chapter" href="graphdb-neo4j.html" title="Chapter 3. The Neo4j Graph Database" /><link rel="part" href="tutorials.html" title="Part II. Tutorials" /><link rel="chapter" href="tutorials-cypher.html" title="Chapter 4. Getting started with Cypher" /><link rel="chapter" href="data-modeling-examples.html" title="Chapter 5. Data Modeling Examples" /><link rel="chapter" href="languages.html" title="Chapter 6. Languages" /><link rel="part" href="cypher-query-lang.html" title="Part III. Cypher Query Language" /><link rel="chapter" href="cypher-intro.html" title="Chapter 7. Introduction" /><link rel="chapter" href="query-syntax.html" title="Chapter 8. Syntax" /><link rel="chapter" href="query-general.html" title="Chapter 9. General Clauses" /><link rel="chapter" href="query-read.html" title="Chapter 10. Reading Clauses" /><link rel="chapter" href="query-write.html" title="Chapter 11. Writing Clauses" /><link rel="chapter" href="query-function.html" title="Chapter 12. Functions" /><link rel="chapter" href="cypher-schema.html" title="Chapter 13. Schema" /><link rel="chapter" href="examples-from-sql-to-cypher.html" title="Chapter 14. From SQL to Cypher" /><link rel="part" href="reference-documentation.html" title="Part IV. Reference" /><link rel="chapter" href="capabilities.html" title="Chapter 15. Capabilities" /><link rel="chapter" href="transactions.html" title="Chapter 16. Transaction Management" /><link rel="chapter" href="import.html" title="Chapter 17. Data Import" /><link rel="chapter" href="graph-algo.html" title="Chapter 18. Graph Algorithms" /><link rel="chapter" href="rest-api.html" title="Chapter 19. REST API" /><link rel="chapter" href="deprecations.html" title="Chapter 20. Deprecations" /><link rel="part" href="operations.html" title="Part V. Operations" /><link rel="chapter" href="deployment.html" title="Chapter 21. Installation &amp; Deployment" /><link rel="chapter" href="embedded-configuration.html" title="Chapter 22. Configuration &amp; Performance" /><link rel="chapter" href="ha.html" title="Chapter 23. High Availability" /><link rel="chapter" href="operations-backup.html" title="Chapter 24. Backup" /><link rel="chapter" href="operations-security.html" title="Chapter 25. Security" /><link rel="chapter" href="operations-monitoring.html" title="Chapter 26. Monitoring" /><link rel="part" href="tools.html" title="Part VI. Tools" /><link rel="chapter" href="tools-webadmin.html" title="Chapter 27. Web Interface" /><link rel="chapter" href="shell.html" title="Chapter 28. Neo4j Shell" /><link rel="part" href="community.html" title="Part VII. Community" /><link rel="chapter" href="community-support.html" title="Chapter 29. Community Support" /><link rel="chapter" href="community-contributing.html" title="Chapter 30. Contributing to Neo4j" /><link rel="part" href="advanced-usage.html" title="Part VIII. Advanced Usage" /><link rel="chapter" href="server-extending.html" title="Chapter 31. Extending the Neo4j Server" /><link rel="chapter" href="tutorials-java-embedded.html" title="Chapter 32. Using Neo4j embedded in Java applications" /><link rel="chapter" href="tutorial-traversal.html" title="Chapter 33. The Traversal Framework" /><link rel="chapter" href="indexing.html" title="Chapter 34. Legacy Indexing" /><link rel="chapter" href="batchinsert.html" title="Chapter 35. Batch Insertion" /><link rel="appendix" href="manpages.html" title="Appendix A. Manpages" /><link rel="refentry" href="re01.html" title="neo4j" /><link rel="refentry" href="re02.html" title="neo4j-installer" /><link rel="refentry" href="re03.html" title="neo4j-shell" /><link rel="refentry" href="re04.html" title="neo4j-backup" /><link rel="refentry" href="re05.html" title="neo4j-arbiter" /><link rel="subsection" href="introduction-pattern.html#_patterns_for_nodes" title="8.5.1. Patterns for nodes" /><link rel="subsection" href="introduction-pattern.html#_patterns_for_related_nodes" title="8.5.2. Patterns for related nodes" /><link rel="subsection" href="introduction-pattern.html#_labels" title="8.5.3. Labels" /><link rel="subsection" href="introduction-pattern.html#_specifying_properties" title="8.5.4. Specifying properties" /><link rel="subsection" href="introduction-pattern.html#_describing_relationships" title="8.5.5. Describing relationships" /><link rel="subsection" href="introduction-pattern.html#_assigning_to_path_identifiers" title="8.5.6. Assigning to path identifiers" /><link rel="copyright" href="ln-idp218960.html" title="License: Creative Commons 3.0" />


<!-- favicon -->

<link rel="shortcut icon" href="http://neo4j.org/favicon.ico" type="image/vnd.microsoft.icon" />
<link rel="icon" href="http://neo4j.org/favicon.ico" type="image/x-icon" />

<!-- style -->

<link href="css/shCore.css" rel="stylesheet" type="text/css" />
<link href="css/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/shThemeEclipse.css" rel="stylesheet" type="text/css" />
<link href="css/neo.css" rel="stylesheet" type="text/css" />

<!-- Syntax Highlighter -->

<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushJava.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushBash.js"></script>
<script type="text/javascript" src="js/shBrushPlain.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushGroovy.js"></script>
<script type="text/javascript" src="js/shBrushCypher.js"></script>
<script type="text/javascript" src="js/shBrushScala.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript" src="js/shBrushPython.js"></script>
<script type="text/javascript" src="js/shBrushProperties.js"></script>

<!-- activate when needed
<script type="text/javascript" src="js/shBrushRuby.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
-->
 
<script type="text/javascript">
  SyntaxHighlighter.defaults['tab-size'] = 4;
  SyntaxHighlighter.defaults['gutter'] = false;
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all()
</script>

<!-- JQuery -->

<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>

<!-- Replace SVG for browsers that lack support. -->
<script type="text/javascript" src="js/svgreplacer.js"></script>

<!-- Image Scaler -->

<script type="text/javascript" src="js/imagescaler.js"></script>

<!-- Table Styler -->

<script type="text/javascript" src="js/tablestyler.js"></script>

<!-- Version -->

<script type="text/javascript" src="js/version.js"></script>

<!-- Offline Sidebar -->

<script type="text/javascript" src="js/sidebar.js"></script>


<div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">The Neo4j Manual</a></span> &gt; <span class="breadcrumb-link"><a href="cypher-query-lang.html">Cypher Query Language</a></span> &gt; <span class="breadcrumb-link"><a href="query-syntax.html">Syntax</a></span> &gt; <span class="breadcrumb-node">Patterns</span></div></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="cypher-comments.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="syntax-collections.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="introduction-pattern"></a>8.5. Patterns</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="introduction-pattern.html#_patterns_for_nodes">8.5.1. Patterns for nodes</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_patterns_for_related_nodes">8.5.2. Patterns for related nodes</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_labels">8.5.3. Labels</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_specifying_properties">8.5.4. Specifying properties</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_describing_relationships">8.5.5. Describing relationships</a></span></dt><dt><span class="section"><a href="introduction-pattern.html#_assigning_to_path_identifiers">8.5.6. Assigning to path identifiers</a></span></dt></dl></div><p>Patterns and pattern-matching are at the very heart of Cypher, so being effective with Cypher requires a good understanding of patterns.</p><p>Using patterns, you describe the shape of the data you’re looking for. For example, in the <code class="literal">MATCH</code> clause you describe the shape with a pattern, and Cypher will figure out how to get that data for you.</p><p>The pattern describes the data using a form that is very similar to how one typically draws the shape of property graph data on a whiteboard: usually as circles (representing nodes) and arrows between them to represent relationships.</p><p>Patterns appear in multiple places in Cypher: in <code class="literal">MATCH</code>, <code class="literal">CREATE</code> and <code class="literal">MERGE</code> clauses, and in pattern expressions. Each of these
is described in more details in:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<a class="xref" href="query-match.html" title="10.1. Match">Section 10.1, “Match”</a>
</li><li class="listitem">
<a class="xref" href="query-optional-match.html" title="10.2. Optional Match">Section 10.2, “Optional Match”</a>
</li><li class="listitem">
<a class="xref" href="query-create.html" title="11.1. Create">Section 11.1, “Create”</a>
</li><li class="listitem">
<a class="xref" href="query-merge.html" title="11.3. Merge">Section 11.3, “Merge”</a>
</li><li class="listitem">
<a class="xref" href="query-where.html#query-where-patterns" title="10.3.3. Using patterns in WHERE">Section 10.3.3, “Using patterns in WHERE”</a>
</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_patterns_for_nodes"></a>8.5.1. Patterns for nodes</h3></div></div></div><p>The very simplest “shape” that can be described in a pattern is a node. A node is described using a pair of parentheses, and is typically given a name.
For example:</p><p><code class="literal"><code class="literal">(a)</code></code></p><p>This simple pattern describes a single node, and names that node using the identifier <code class="literal">a</code>.</p><p>Note that the parentheses may be omitted, but only when there are no labels or properties specified for the node pattern.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_patterns_for_related_nodes"></a>8.5.2. Patterns for related nodes</h3></div></div></div><p>More interesting is patterns that describe multiple nodes and relationships between them.
Cypher patterns describe relationships by employing an arrow between two nodes.
For example:</p><p><code class="literal"><code class="literal">(a)--&gt;(b)</code></code></p><p>This pattern describes a very simple data shape: two nodes, and a single relationship from one to the other.
In this example, the two nodes are both named as <code class="literal">a</code> and <code class="literal">b</code> respectively, and the relationship is “directed”: it goes from <code class="literal">a</code> to <code class="literal">b</code>.</p><p>This way of describing nodes and relationships can be extended to cover an arbitrary number of nodes and the relationships between them, for example:</p><p><code class="literal"><code class="literal">(a)--&gt;(b)&lt;--(c)</code></code></p><p>Such a series of connected nodes and relationships is called a "path".</p><p>Note that the naming of the nodes in these patterns is only necessary should one need to refer to the same node again, either later in the pattern or elsewhere in the Cypher query.
If this is not necessary then the name may be omitted, like so:</p><p><code class="literal"><code class="literal">(a)--&gt;()&lt;--(c)</code></code></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_labels"></a>8.5.3. Labels</h3></div></div></div><p>In addition to simply describing the shape of a node in the pattern, one can also describe attributes.
The most simple attribute that can be described in the pattern is a label that the node must have.
For example:</p><p><code class="literal"><code class="literal">(a:User)--&gt;(b)</code></code></p><p>One can also describe a node that has multiple labels:</p><p><code class="literal"><code class="literal">(a:User:Admin)--&gt;(b)</code></code></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_specifying_properties"></a>8.5.4. Specifying properties</h3></div></div></div><p>Nodes and relationships are the fundamental structures in a graph. Neo4j uses properties on both of these to allow for far richer models.</p><p>Properties can be expressed in patterns using a map-construct: curly brackets surrounding a number of key-expression pairs, separated by commas.
E.g. a node with two properties on it would look like:
<code class="literal"><code class="literal">(a { name: "Andres", sport: "Brazilian Ju-Jitsu" })</code>.</code></p><p>A relationship with expectations on it would could look like:
<code class="literal"><code class="literal">(a)-[{blocked: false}]-&gt;(b)</code>.</code></p><p>When properties appear in patterns, they add an additional constraint to the shape of the data.
In the case of a <code class="literal">CREATE</code> clause, the properties will be set in the newly created nodes and relationships.
In the case of a <code class="literal">MERGE</code> clause, the properties will be used as additional constraints on the shape any existing data must have (the specified properties must exactly match any existing data in the graph).
If no matching data is found, then <code class="literal">MERGE</code> behaves like <code class="literal">CREATE</code> and the properties will be set in the newly created nodes and relationships.</p><p>Note that patterns supplied to <code class="literal">CREATE</code> may use a single parameter to specify properties, e.g: <code class="literal">CREATE (node {paramName})</code>.
This is not possible with patterns used in other clauses, as Cypher needs to know the property names at the time the query is compiled, so that matching can be done effectively.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_describing_relationships"></a>8.5.5. Describing relationships</h3></div></div></div><p>The simplest way to describe a relationship is by using the arrow between two nodes, as in the previous examples.
Using this technique, you can describe that the relationship should exist and the directionality of it.
If you don’t care about the direction of the relationship, the arrow head can be omitted, like so:</p><p><code class="literal"><code class="literal">(a)--(b)</code></code></p><p>As with nodes, relationships may also be given names.
In this case, a pair of square brackets is used to break up the arrow and the identifier is placed between.
For example:</p><p><code class="literal"><code class="literal">(a)-[r]-&gt;(b)</code></code></p><p>Much like labels on nodes, relationships can have types.
To describe a relationship with a specific type, you can specify this like so:</p><p><code class="literal"><code class="literal">(a)-[r:REL_TYPE]-&gt;(b)</code></code></p><p>Unlike labels, relationships can only have one type.
But if we’d like to describe some data such that the relationship could have any one of a set of types, then they can all be listed in the pattern, separating them with the pipe symbol <code class="literal">|</code> like this:</p><p><code class="literal"><code class="literal">(a)-[r:TYPE1|TYPE2]-&gt;(b)</code></code></p><p>Note that this form of pattern can only be used to describe existing data (ie. when using a pattern with <code class="literal">MATCH</code> or as an expression).
It will not work with <code class="literal">CREATE</code> or <code class="literal">MERGE</code>, since it’s not possible to create a relationship with multiple types.</p><p>As with nodes, the name of the relationship can always be omitted, in this case like so:</p><p><code class="literal"><code class="literal">(a)-[:REL_TYPE]-&gt;(b)</code></code></p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_variable_length"></a>Variable length</h4></div></div></div><p>Rather than describing a long path using a sequence of many node and relationship descriptions in a pattern, many relationships (and the intermediate nodes) can be described by specifying a length in the relationship description of a pattern.
For example:</p><p><code class="literal"><code class="literal">(a)-[*2]-&gt;(b)</code></code></p><p>This describes a graph of three nodes and two relationship, all in one path (a path of length 2).
This is equivalent to:</p><p><code class="literal"><code class="literal">(a)--&gt;()--&gt;(b)</code></code></p><p>A range of lengths can also be specified: such relationship patterns are called “variable length relationships”.
For example:</p><p><code class="literal"><code class="literal">(a)-[*3..5]-&gt;(b)</code></code></p><p>This is a minimum length of 3, and a maximum of 5.
It describes a graph of either 4 nodes and 3 relationships, 5 nodes and 4 relationships or 6 nodes and 5 relationships, all connected together in a single path.</p><p>Either bound can be omitted. For example, to describe paths of length 3 or more, use:</p><p><code class="literal"><code class="literal">(a)-[*3..]-&gt;(b)</code></code></p><p>And to describe paths of length 5 or less, use:</p><p><code class="literal"><code class="literal">(a)-[*..5]-&gt;(b)</code></code></p><p>Both bounds can be omitted, allowing paths of any length to be described:</p><p><code class="literal"><code class="literal">(a)-[*]-&gt;(b)</code></code></p><p>As a simple example, let’s take the query below:</p><p><strong>Query. </strong>
</p><pre class="programlisting brush: cypher">MATCH (me)-[:KNOWS*1..2]-(remote_friend)
WHERE me.name = "Filipa"
RETURN remote_friend.name</pre><p>
</p><div class="queryresult table"><a id="idp7925456"></a><p class="title"><strong>Result</strong></p><div class="queryresult table-contents"><table summary="Result" cellspacing="0" cellpadding="0" border="1"><colgroup><col class="col1" /></colgroup><thead><tr><th align="left" valign="top">remote_friend.name</th></tr></thead><tfoot><tr><th align="left" valign="top">2 rows</th></tr></tfoot><tbody><tr><td align="left" valign="top"><p><code class="literal">"Dilshad"</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">"Anders"</code></p></td></tr></tbody></table></div></div><br class="queryresult table-break" /><p>This query finds data in the graph which a shape that fits the pattern: specifically a node (with the name property <code class="literal">Filipa</code>) and then the <code class="literal">KNOWS</code> related nodes, one or two steps out.
This is a typical example of finding first and second degree friends.</p><p>Note that variable length relationships can not be used with <code class="literal">CREATE</code> and <code class="literal">MERGE</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_assigning_to_path_identifiers"></a>8.5.6. Assigning to path identifiers</h3></div></div></div><p>As described above, a series of connected nodes and relationships is called a "path". Cypher allows paths to be named
using an identifer, like so:</p><p><code class="literal"><code class="literal">p = (a)-[*3..5]-&gt;(b)</code></code></p><p>You can do this in <code class="literal">MATCH</code>, <code class="literal">CREATE</code> and <code class="literal">MERGE</code>, but not when using patterns as expressions.</p></div></div><HR xmlns=""></HR><a xmlns="" href="ln-idp218960.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2013 Neo Technology</p></a><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="cypher-comments.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="query-syntax.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="syntax-collections.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
